
Mastering complexity is the most essential thing in software engineering. Avoiding it is our task. Allow it only when it is essential and cannot be avoided because the value it creates justifies the cost of complexity.

The best code is the code that does not need to be written.

Unfortunately, we often see precisely the opposite happening. Especially with supposedly "senior" colleagues who are attracted to complexity like moths to a flame. Often with the same result.

They are only fuelling their ego by wanting to show how well they can master complexity. Often they overestimate their abilities. Even if they don't, they don't consider that software engineering is a highly collaborative discipline. It is not enough for 1 engineer to understand a complex system. The whole team has to understand it—even or especially the junior engineers.

So what can we do?

Avoiding it whenever possible. But when is it possible and when not? I guess the answer only can be "It depends!". 

But the first thing we can do is learn about the concept of essential complexity and accidental complexity. The concept was introduced by Turing Award winner Fred Brooks who is mostly known for his paper "No Silver Bullet—Essence and Accident in Software Engineering". 

## Accidental complexity
Accidental complexity refers to challenges that developers unintentionally make for themselves as a result of trying to solve a problem.  It is the stuff you don´t need. Fortunately, this kind of complexity can also be fixed or improved by developers.

Examples are databases, external systems, frameworks, programming languages, and so on.


## Essential complexity
When accidental complexity is the stuff you don´t need, essential complexity is what you need. But what is essential to solving the problem?

Probably the best example of essential complexity is our business logic. It is the place where the actual value of the product gets manifested into code. Removing it will decrease the value.

## But what is complexity?
There are a lot of different types of complexity out there (Wikipedia)[https://en.wikipedia.org/wiki/Complexity]. But we want to classify complexity in software engineering like this:

### Behavior driven
When you don´t know how the system behaves. When you don´t know how the system reacts as you add more code or change existing. It is what happens when everything depends on each other and shares every information with each other.

### Quantity driven
Here complexity gets created just by the sheer size of a system. It has lots of components. And even when the logic of every component is easy to understand or already well-known, it is hard to understand the system as a whole. 

So, in general, complexity means not knowing anything about a system.

## Tackling Accidental complexity
The first challenge is to identify what you need and what not. And this requires some really good technical skills and experience.